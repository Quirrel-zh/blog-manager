{"posts":[{"title":"第一篇文章","text":"TEST人生不是马拉松，终点不只一个。不管直路弯路，是走是爬，你的路都是独一无二的。不管是穷困或富贵，成功都是你定义的。","link":"/2024/08/19/new/"},{"title":"如何在centOS中配置环境等","text":"本文章于 2023 年学习时记录，无法保证准确性 centOS 安装以及宿主机的连接安装 centOS​ 根据 iso 安装需要版本的 centOS，可选带有桌面或者无桌面的内核版本 检查 centOS 版本以及网络状态12cat /etc/redhat-release # 查询centOS的版本ip addr #查询ip 默认状态下看不到ip 但是需要记住网卡名称例如ens33 ip 地址默认看不到，需要我们设置一下网络配置 12cd /etc/sysconfig/network-scripts #切换目录vi ifcfg-ens33 # 修改指定的网卡 进入到 ifcfg-ens33 之后需要修改BOOTPROTO以及ONBOOT两行 123BOOTPROTO = &quot;dhcp&quot; #更改为静态ipONBOOT = &quot;yes&quot; #更改网卡状态开启# 随后按下esc 输入:wq回车退出 此时 ip 地址即可查看 12ip addr# 找到目标网卡inet后的ip地址 此时可以用 ping www.baidu.com来验证网络是否已连接 使用 Xshell 以及 Xftp 进行连接在 Xshell 新建会话，用户名使用 centOS 中查到的 ip，用户名为 root 密码为初始创建的密码 同理 Xftp 也是一样 JDK 以及 mysql 的环境安装配置JDK 的安装在 usr 目录下新建一个 jdk 的文件12cd /usr/local # 切换目录到指定位置mkdir jdk # 创建名为jdk 的文件 使用 Xftp 进行宿主机与虚拟机间的文件传输将 jdk 压缩包传到/usr/local/jdk 中 使用代码解压 1tar zxvf &quot;jdk文件名.tar.gz&quot; 不同压缩包的解压方式 123456tar –xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2 //解压 tar.bz2tar –xZvf file.tar.Z //解压tar.Zunrar e file.rar //解压rarunzip file.zip //解压zip 编辑环境变量，以及验证 jdk1234567vi /etc/profile # 编辑环境变量# 在文末加入路径代码# jdk configJAVA_HOME=/usr/local/jdk/jdk1.8.0_391CLASS_PATH=$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASS_PATH PATH 编辑完成按下 esc 键退出编辑模式，再按下**:wq**回车退出保存 使用source /etc/profile使配置生效 验证 java 12java -versionjps mySQL 的安装使用 Xftp 将需要安装的 mysql 传输到虚拟机中 解压改名以及移动文件名以mysql-5.7.43.tar.gz示例 123tar zxvf mysql-5.7.43.tar.gz # 解压mv mysql-5.7.43 mysql # 改名为mysqlmv mysql /usr/local # 移动到常用目录中 创建一个新的 mysql 用户 删除系统已有的数据库 否则会导致 mysql 安装冲突 123# 删除mariadbrpm -qa|grep mariadb # 列出所有mariadb数据库，有多少下面删多少rpm -e --nodeps &quot;要删除的数据库&quot; 创建一个不需要登录的 mysql 账号，给对应的目录授予权限 1234567# 创建不需要登录的mysql账号groupadd mysqluseradd -r -g mysql -s /bin/false mysql# 给予权限chown -R mysql:mysql /usr/local/mysqlmkdir -p /data/mysqlchown -R mysql:mysql /data/mysql 安装依赖1yum -y install libaio # 从云端安装需要的依赖包 初始化 mysql 以及配置环境变量 对 mysql 进行初始化 12cd /usr/local/mysql/bin # 切换到mysql的bin目录./mysqld --user=mysql --initialize # 进行初始化 初始化后会显示初始的 root 账户密码，在最后一行localhost:后，后续需要使用这个密码进行登录 mysql 添加环境变量 首先进入到环境变量配置文件中 1vi /etc/profile 在环境变量最后加入 mysql 路径 1234# mysql congfigMYSQL_HOME=/opt/apps/mysqlPATH=$PATH:{MYSQL_HOME}/binexport MYSQL_HOME PATH 添加到系统服务 进入 mysql.server 进行编辑 12cd support-filesvi mysql.server 进入到编辑页面后修改basedir、datadir以及mysql_pid_file_path的量 123basedir=/usr/local/mysqldatadir=/data/mysql/datamysql_pid_file_path=/data/mysql/mysql.pid 编辑完后按下esc退出编辑模式，再按下:wq保存退出 设置开机启动，更改目录权限 1234567# 给予权限cp mysql.server /etc.init.d/mysqlchmod 755 /etc/init.d/mysql# 启动mysqlservice mysql startchkconfig --add mysqlchkconfig --list 修改 root 密码使用上面准备好的 root 密码登录到 mysql 12mysql -uroot -p# 回车后输入刚刚得到的密码 注意：如果此时显示未找到 mysql 命令时，是因为系统默认查找/usr/bin 下的命令，如果命令不在此处，需要映射一个链接到/usr/bin 目录下 1、找到 mysql 的安装路径 1whereis mysql 2、确定安装路径在/usr/local/mysql/bin/mysql下后，创建一个软连接 1ln -s /usr/local/mysql/bin/mysql /usr/bin 3、再次进行登录尝试 1mysql -uroot -p 登录后修改密码为指定密码 12alter user 'root'@'localhost' identified by '123456'; # 修改密码为123456 注意代码末需要带分号flush privileges; # 刷新权限 tomcat 的安装与部署使用 Xftp 将需要安装的 Tomcat 传输到虚拟机中在/usr/local/目录下新建名为tomcat的文件夹 将需要安装的 Tomcat 通过 Xftp 移动到此处 解压文件1tar -zxvf apache-tomcat.tar.gz 启动 tomcat 首先进入到 tomcat 目录下的bin目录 1cd /usr/local/tomcat/apache-tomcat.9.0.83/bin/ 根据指令启动 tomcat 1./startup.sh 进入到日志验证是否正常启动，并查看开放端口号 12345# 进入日志目录cd ..cd logs/# 查看日志最后100行tail -100f catalina.out 如果日志内没有报错，查看**开始协议处理句柄[“http-nio-8080”]**中后四位的端口号，这里以 8080 举例。 测试访问 tomcat 去浏览器访问ip:端口号的网址 示例192.168.174.130:8080在地址栏直接访问 但是这时会无法访问，需要进行防火墙的开放 开启防火墙端口 1234567# 开启指定端口的防火墙 以8080举例firewall-cmd --zone=public --add-port=8080/tcp --permanent#命令含义： -zone #作用域 -add-port=8080/tcp # 添加端口 格式为：端口/通讯协议 -permanent # 永久生效，没有此参数重启后失效# 重启防火墙firewall-cmd --reload 访问 tomcat 此时去浏览器地址页输入192.168.174.130:8080即可访问 tomcat 主页 部署项目到 tomcact 关闭 tomcat 部署先需要先关闭 tomcat 12345# 返回到bin目录cd ..cd bin/# 输入关闭指令./shutdown.sh 导入项目 将事先准备好的项目通过 Xftp 导入到 tomcat 目录下的/webapps/下，下面以examtest 为例。 访问项目 重新开启 tomcat 12345./startup.sh# 再去日志看看是否正常开启cd ..cd logs/tail -100f catalina.out 成功开启后进入个人项目页面 浏览器访问 192.168.174.130:8080/examtest/ 项目名是什么，端口后就是什么","link":"/2024/08/29/CentOS-jdk/"},{"title":"TypeScript 极速梳理","text":"JavaScript是非常灵活的一门编程语言，但是这种灵活是把双刃剑，一方面使得JavaScript蓬勃发展，无所不能；另一方面也使它的代码质量参差不齐，维护成本高，运行时错误多。 TypeScript是具有类型的JavaScript，在很大程度上弥补了它的缺点。 类型声明给变量声明类型： 123456789101112let a:string // 变量a只能存储字符串let b:number // 变量b只能存储数值let c:boolean // 变量c只能存储布尔值a = 'hello'a = 100 // 警告：不能将类型&quot;number&quot;分配给类型&quot;string&quot;b = 666b = '你好' // 警告：不能将类型&quot;string&quot;分配给类型&quot;number&quot;c = truec = 666 // 警告： 不能将类型&quot;number&quot;分配给类型&quot;boolean&quot; 给参数声明类型 12345678// 给x和y传递参数时必须传递数字类型，返回值也必须是数字function demo(x:number,y:number):number{ return x + y}demo(100, 200)demo(100, '200') // 警告：类型&quot;string&quot;的参数不能赋给类型&quot;number&quot;的参数demo(100, 200, 300) // 警告：应有 2 个参数，但获得 3 个 类型推断在没有声明类型的情况下，ts会自行推断出类型 12let d = -99 // 此时会自动推断变量d的类型为数字d = false // 警告：不能将类型&quot;boolean&quot;分配给类型&quot;number&quot; 类型总览JavaScript中的数据类型： JavaScript string、number、boolean、null、undefined、bigint、symbol、object 备注： 其中object包括：Array、Function、Date….. TypeScript中的数据类型： TypeScript ​ · 以上所有 ​ · 四个新类型：void、 never、unknown、any、enum、tuple ​ · 自定义类型：type&amp;interface 注意：JavaScript中的三个构造函数：Number、String、Boolean，他们只用于包装对象，正常开发时，很少去使用他们，在TypeScript中也是同理 总览： 类型 描述 举例 number 任意数字 1，-1，1.5 string 任意字符串 'nihao'，'你好'，'hello' boolean 布尔值 true&amp;false 字面量 值只能是字面量值 值本身 any 任意类型 1，'hello'，true…… unknown 类型安全的any 1，'hello'，true…… never 不能是任何值 无值 void 空 或 undefined 空 或 undefined object 任意JS对象 {name: '张三'} tuple 元素，TS新增类型，固定长度数组 [3, 4] enum 枚举，TS新增类型 enum{A, B} 常用类型字面量123456789let a:'你好' // a的值只能是字符串'你好'let b:100 // b的值只能是数字100 a = 'hello' // 警告：不能将类型“'hello'”分配给类型“'你好'”b = 200 // 警告：不能将类型“200”分配给类型“100”let gender:'男'|'女' // 定义一个变量gender，值只能为字符串“男”或“女”gender = '男'gender = '未知' // 警告：不能将类型“'未知'”分配给类型“'男'|'女'” anyany的含义是：任何类型。 一旦将变量类型限制为any，那就意味着放弃了对该变量的类型检查。 12345678910111213// 明确表示a的类型是any —— 显式的anylet a:any // 以下对a的赋值，均⽆警告a = 100a = '你好'a = false // 没有明确的表示b的类型是any，但TS主动推断了出来 —— 隐式的anylet b // 以下对b的赋值，均⽆警告b = 100b = '你好'b = false 注意： any 类型的变量，可以赋值给任意类型的变量 ： 123let alet x:stringx = a // ⽆警告 unknownunknown的含义是：未知类型 unknown可以理解为一个类型安全的any unknown适用于：开始不知道数据的具体类型，后期才能确定数据的类型 1234567891011// 设置a的类型为unknownlet a: unknown// 以下对a的赋值均无警告a = 100a = falsea = '你好'// 设置x的数据类型为stringlet x:stringx = a // 警告： 不能将类型'unknown'分配给类型'string' 如果想把a赋值给x， 可以用以下三种写法： 1234567891011121314// 设置a的类型为unknownlet a:unknowna = 'hello'// 1、类型判断if (typeof a === 'string'){ x = a}// 2、断言x = a as string// 3、断言的另外一种写法x = &lt;string&gt;a any后点任何的东西都不会报错，unknown则相反 1234567891011let str1:string = 'hello'str1.toUpperCase() // 无警告let str2:any = 'hello'str2.toUpperCase() // 无警告let str3:unknown = 'hello'str3.toUpperCase() // 警告：&quot;str3&quot;的类型为未知// 使用断言强制指定str3的类型为string(str3 as string).toUpperCase() // 无警告 nevernever的含义是：任何值都不是，简言之就是不能有值，undefined、null、''、0都不行！ 几乎不用never去限制变量，因为没有意义，例如： 12345678// 指定a的类型为never，那就意味着a以后不能存任何的数据let a:never// 以下对a的赋值都会有警告a = 1a = truea = undefineda = null never一般是TypeScript主动推断出来的，例如： 12345678910// 指定a的类型为stringlet a:string// 给a设置一个值a = 'hello'if(typeof a === 'string'){ a.toUpperCase()} else{ console.log(a) // TypeScript会推断出此处的a是never，因为没有任何一个值符合此处的逻辑} never也可以用于限制函数的返回值 1234// 限制demo函数不需要有任何返回值，任何值都不行，想undefined和null都不行function demo():never{ throw new Error('程序异常退出')} voidvoid的含义是：空或者undefined，严格模式下不能加null赋值给void类型。 1234let a:void = undefined// 严格模式下，该行会有警告：不能将类型“null”分配给类型“void”let b:void = null void常用于限制函数返回值 12345678910111213141516171819// 无警告function demo1():void{ }// 无警告function demo2():void{ return}// 无警告function demo3():void{ return undefined}// 警告：不能将类型“number”分配给类型“void”function demo4():void{ return 666} object关于Object与object，直接说结论：在类型限制时，Object几乎不用，因为范围太大没有意义。 object 的含义：任何【⾮原始值类型】，包括：对象、函数、数组等，限制的范围⽐较宽泛，⽤的少 1234567891011121314let a:object // a的值可以是任何【⾮原始值类型】，包括：对象、函数、数组等// 以下代码，是将【⾮原始类型】赋给a，所以均⽆警告a = {}a = {name: '张三'}a = [1, 3, 5, 7, 9]a = function(){} // 以下代码，是将【原始类型】赋给a，有警告a = null // 警告：不能将类型“null”分配给类型“object”a = 1 // 警告：不能将类型“number”分配给类型“object”a = true // 警告：不能将类型“boolean”分配给类型“object”a = undefined // 警告：不能将类型“undefined”分配给类型“object”a = '你好' // 警告：不能将类型“string”分配给类型“object” Object的含义：Object的实例对象，限制范围太大了，几乎不用 1234567891011121314let a:Object //a的值必须是Object的实例对象，// 以下代码，均⽆警告，因为给a赋的值，都是Object的实例对象a = {}a = {name:'张三'}a = [1,3,5,7,9]a = function(){}a = 1 // 1不是Object的实例对象，但其包装对象是Object的实例a = true // true不是Object的实例对象，但其包装对象是Object的实例a = '你好' // “你好”不是Object的实例对象，但其包装对象是Object的实例// 以下代码均有警告a = null // 警告：不能将类型“null”分配给类型“Object”a = undefined // 警告：不能将类型“undefined”分配给类型“Object” 实际开发中，限制一般对象，通常使用一下形式 123456789101112131415161718192021222324// 限制person对象的具体内容，使用','分隔，问号代表可选属性let person:{ name:string, age?:number,}// 限制car对象的具体内容，使用';'分隔，必须有price和color属性，其他属性不去限制，有没有都行let car:{ price: number; color: string; [k:string]:any}// 限制student对象的具体内容，使用'回车'分隔。let student:{ id:string, grade:number,}// 以下代码均无警告person = {name: '张三', age: 18,}person = {name: '李四'}car = {price: 100, color: '红色'}student = {id: '123', grade: 3} 限制函数的参数、返回值，使⽤以下形式 12345let demo:(a:number, b:number) =&gt; numberdemo = function(x, y){ return x + y} 限制数组，使用以下形式 12345let arr1:string[] // 等价于 let arr1:Array&lt;string&gt;let arr2:number[] //等价于 let arr2:Array&lt;number&gt;arr1 = ['a', 'b', 'c']arr2 = [1, 3, 5, 7, 9] tupletuple就是一个长度固定的数组。 123456let t:[string, number]t = ['hello', 123]// 警告：不能将类型“[string, number, boolean]”分配给类型“[string, number]”t = ['hello', 123, false] enumenum是枚举 点击展开 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 定义一个枚举enum Color { Red, Blue, Blace, Gold,}// 定义一个枚举，并指定其初始数值enum Color2{ Red = 6, Blue, Black, Gold,}console.log(Color)/* { 0: 'Red', 1: 'Blue', 2: 'Black', 3: 'Gold', Red: 0, Blue: 1, Black: 2, Gold: 3 } */console.log(Color2)/* { 6: 'Red', 7: 'Blue', 8: 'Black', 9: 'Gold', Red: 6, Blue: 7, Black: 8, Gold: 9 } */// 定义一个phone变量，并对其设置限制let phone: { name:string, price:number, color:Color,}phone = { name: 'iPhone', price: '6000' color: Color.Red}if(phone.color === Color.Red){ console.log('手机是红色的')} 自定义类型⾃定义类型，可以更灵活的限制类型 1234567891011121314151617181920212223242526272829303132// 性别的枚举enum Gender { Male, Female}// ⾃定义⼀个年级类型（⾼⼀、⾼⼆、⾼三）type Grade = 1 | 2 | 3// ⾃定义⼀个学⽣类型type Student = { name: string, age: number, gender: Gender, grade: Grade}// 定义两个学⽣变量：s1、s2let s1:Studentlet s2:Students1 = { name:'张三', age:18, gender:Gender.Male, grade:1}s2 = { name:'李四', age:18, gender:Gender.Female, grade:2} 抽象类常规类： 12345678910111213class Person { name: string age: number constructor(name:string,age:number){ this.name = name this.age = age }}const p1 = new Person('张三',18)const p2 = new Person('李四',19)console.log(p1)console.log(p2) 继承： 12345678910111213141516171819202122232425262728// Person类class Person { name: string age: number}// Teacher类继承Personclass Teacher extends Person { name: string age: number}// Student类继承Personclass Student extends Person { name: string age: number}// Person实例const p1 = new Person('周杰伦', 38)// Student实例const s1 = new Student('张同学', 18)const s2 = new Student('李同学', 20)// Teacher实例const t1 = new Teacher('刘⽼师', 40)const t2 = new Teacher('孙⽼师', 50) 抽象类：不能去实例化，但可以被别⼈继承，抽象类⾥有抽象⽅法 1234567891011121314151617181920212223242526272829// Person（抽象类）abstract class Person { name: string age: number}// Teacher类继承Personclass Teacher extends Person { name: string age: number // 构造器 constructor(name: string, age: number){ super(name, age) } // ⽅法 speak(){ console.log('你好！我是⽼师:', this.name) }}// Student类继承Personclass Student extends Person { name: string age: number}// Person实例// const p1 = new Person('周杰伦',38) // 由于Person是抽象类，所以此处不可以new Person的实例对象 接口接口梳理： 接口用于限制一个类中包含那些属性和方法： 1234567891011121314151617181920212223// Person 接口interface Person { // 属性声明 name: string age: number // 方法声明 speak():void}// Teacher实现Person接口class Teacher implements Person { name: string age: number // 构造器 constructor(name: string, age: number){ this.name = name this.age = age } // 方法 speak(){ console.log('你好，我是：', this.name) }} 接口是可以重复声明的： 123456789101112131415161718192021222324252627// Person接口 interface PersonInter { // 属性声明 name: sting age: number}// Person接口interface PersonInter { // 方法声明 speak():void}// Person类继承PersonInterclass Person implements PersonInter { name: string age: number // 构造器 constructor(name: string, age: number){ this.name = name this.age = age } // 方法 speak(){ console.log('你好，我是：', this.name) }} “接口”与”自定义类型”的区别： 接口可以： ​ 1. 当自定义类型去使用 2. 可以限制类的结构 自定义类型： ​ 1. 仅仅就是自定义类型 123456789101112131415161718192021222324// Person接口interface Person{ // 应该具有的属性 name: string age: number // 应该具有的方法 speak():void}// Person类型/* * type Person = { * name: string * age: number * }*/ // 接口当自定义类型去使用let person:Person = { name: '张三', age: 18, speak(){ console.log(&quot;你好&quot;) }} “接口”与”抽象类”的区别 抽象类： ​ 1. 以有普通方法，也可以有抽象方法​ 2. 用extends关键字去继承抽象类接口中： ​ 1. 只能有抽象方法​ 2. 使用implements关键字去实现接口 抽象类举例： 1234567891011121314151617181920212223242526// 抽象类 ——— Personabstract class Person{ // 属性 name: string age: number // 构造器 constructor(name:string, age:number){ this.name = name this.age = age } // 抽象方法 abstract speak():void // 普通方法 walk(){ console.log('我在走') }}// Teacher类继承抽象类Personclass Teacher extends Person { constructor(name:string, age:number){ super(name, age) } speak(){ console.log(`我是${this.name}`) }} 接口举例： 1234567891011121314151617181920// 接口 ——— Person, 只能包含抽象方法interface Person { // 属性，不写具体值 name: string age: number // 方法，不写具体实现 speak():void}// 创建Teacher类实现Person接口class Teacher implements Person { name: string age: number constructor(name:string, age:number){ this.name = name this.age = age } speak(){ console.log('我在走') }} 属性修饰符 修饰符 含义 解释 readonly 只读属性 属性无法更改 public 公开的 可以在类、子类和对象中修改 protected 受保护的 可以在类、子类中修改 private 私有的 可以在类中修改 泛型定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时就需要泛型了 举例：&lt;T&gt;就是泛型，（不一定非叫&lt;T&gt;），设置泛型之后即可在函数中使用T来表示该类型： 123456789function text&lt;T&gt;(arg: T): T{ return arg;}// 不指明类型，TS会自动推断出来test(10)// 指明具体的类型test&lt;number&gt;(10) 泛型还可以写多个： 123456function test&lt;T, K&gt;(a: T, b: K) K{ return b}// 为多个泛型指定具体值test&lt;number, string&gt;(10, 'hello') 类中同样可以使用泛型 1234567class MyClass&lt;T&gt;{ prop: T constructor(prop: T){ this.prop = prop }} 也可以对泛型的范围进行约束： 1234567891011121314interface Demo{ length: number}// 泛型T必须是MyInter的子类，即：必须拥有length属性function text&lt;T extends Demo&gt;(arg: T): number{ return arg.length}test(10) // 类型“number”的参数不能赋给类型“Demo”的参数test({name: '张三'}) // 类型“test({name: '张三'})”的参数不能赋给类型“Demo”的参数test('123')test({name:'张三', length: 10}) 结语希望以上笔记能对你有帮助，当然如果你在使用TS时弄不清类型，又不想看到警告，完全可以使用any声明。这也是为什么TypeScript又被大家叫做AnyScript🤪","link":"/2024/09/04/TypeScript/"},{"title":"unittest框架总结以及ddt数据驱动","text":"快速入门本文章于 2023 年学习时记录，无法保证准确性 用例编写unittest 是 Python 自带的一个单元测试框架 此外，unittest 还支持自动化测试的接口测试、UI 测试。 12345678910111213import unittestclass TestDemo(unittest.TestCase): def test_01_demo(self): self.assertEqual(1, 2, &quot;判断1和2相等&quot;) def test_02_demo(self): self.assertEqual(1, 1, &quot;判断1和1相等&quot;)if __name__ == '__main__': unittest.main() 使用 unittest 编写测试用例，必须使用测试类来进行。 在测试类里面的方法就是测试用例了。 注意，测试用例的方法必须是以test开头的才可以。 例如上述代码的test_01_demo unittest.main()会自动的发现模块中的所有测试类中的测试用例。 在测试用例中的方法中，我们可以使用testCase自带的断言功能来实现对预期结果和实践结果的判断。 TestSuite我们可以使用测试套件，把不同的测试用例都加载添加到测试套件中 通过直接运行测试套件来实现运行不同模块中的测试用例 12345import unittestsuite = unittest.TestSuite()case = unittest.defaultTestLoader.discover(start_dir='.', pattern=&quot;test*.py&quot;)suite.addTest(case) 上述代码中使用unittest.defaultTestLoader.discover方法就可以实现在指定的文件夹中区自动的发现我们的测试用例 start_dir后面是测试模块所在的文件目录，如果在同一目录则是. pattern参数后跟的是以 test 开头的 python 文件如”test01.py” “test02.py”，因此我们文件要以有规律化的方式起名 最后使用suite.addTest的方法把发现的测试用例加载到测试套件中。 运行套件以及生成测试报告unittest 自带的测试报告是文本格式的，可读性不好，所以我们一般用第三方的模块来生成测试报告 123456789101112import unittestfrom HTMLTestRunner import HTMLTestRunnersuite = unittest.TestSuite()case = unittest.defaultTestLoader.discover(start_dir='.', pattern=&quot;test*.py&quot;)suite.addTest(case)with open(&quot;测试报告.html&quot;, &quot;wb&quot;)as f: runner = HTMLTestRunner(stream=f, title=&quot;测试报告&quot;, description=&quot;这是项目的描述&quot;) runner.run(suite) HTMLTestRunner是我们经常使用的第三方模块，可以将生成的测试报告以 HTML 方式展现。其中： stream是要把测试报告的文件保存到那个文件目录中 title是测试报告的标题 description是对测试报告的详细描述 assert断言常用的断言 assertEqual判断两个值是否相等 assertNotEqual判断两个值是否不相等 assertTrue判断结果是否为真 assertFalse判断结果是否为假 assertIn判断第一个值是否在第二个值范围内 assertNotIn判断第一个值是否不在第二个值的范围内 assertIs判断两个对象是否属于同一对象 assertIsNot判断两个对象是否不属于同一种对象 assertIsNone判断某个值是否为空 assertIsNotNone判断某个是是否不为空 assertIsInstance判断某个对象是否属于某个 class 实例 assertNotIsInstance判断某个对象是否不属于某个 class 实例 代码示例： 12345678910111213141516171819202122232425262728293031import unittestclass Demo: passclass Demo2: passaa = Demoa = 1b = ac = Noneclass TestDemo(unittest.TestCase): def test_01_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) self.assertTrue(1 == 1, &quot;判断结果是否为真&quot;) self.assertFalse(1 == 2, &quot;判断结果是否为假&quot;) self.assertIn(1, [2, 1, 3], &quot;判断第一个值是否在第二个容器内&quot;) self.assertNotIn(1, [3, 2, 3], &quot;判断第一个值是否不在第二个容器内&quot;) self.assertIs(a, b, &quot;判断任意两个对象是否属于同一个对象&quot;) self.assertIsNot(a, 3, &quot;判断任意两个对象是否不属于同一个对象&quot;) self.assertIsNone(c, &quot;判断某个值是否为空值&quot;) self.assertIsNotNone(a, &quot;判断某个值是否不为空&quot;) self.assertIsInstance(aa, Demo, &quot;判断某个对象是否属于某个class实例&quot;) self.assertNotIsInstance(aa, Demo2, &quot;判断某个对象是否不属于某个class实例&quot;)if __name__ == '__main__': unittest.main() unittest装饰器testCase带有很多不同的装饰器来实现我们测试用例的运行过程。 但是在实际工作中会有大量的测试用例，但不是所有的用例都是需要运行的。 有的用例需要根据不同的情况来判断是否需要运行。 我们可以利用testCase自带的装饰器来实现用例运行过程的控制。 装饰器@unittest.skip() 控制某条用例不运行 @unittest.skipif() 如果条件为真，用例不运行 @unittest.skipUnless()如果条件为假，用例不运行 @unittest.expectedFailure预期测试失败，失败时输出x成功时输出u 例如： 1234567891011121314151617181920212223242526272829303132333435class TestDemo(unittest.TestCase): def test_01_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) def test_02_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 1, &quot;判断两个值是否不相等&quot;) @unittest.skip(&quot;跳过第三条用例&quot;) def test_03_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) @unittest.skipIf(True, &quot;结果为真，跳过用例&quot;) def test_04_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) @unittest.skipUnless(False, &quot;结果为假，跳过用例&quot;) def test_05_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) @unittest.expectedFailure # 预期失败 def test_06_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 1, &quot;判断两个值是否不相等&quot;) @unittest.expectedFailure def test_07_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) 控制台结果： 1234.Fsssxu======================================================================FAIL: test_02_demo (__main__.TestDemo.test_02_demo)---------------------------------------------------------------------- 运行结果的说明.表示测试通过 F表示测试失败 s表示测试跳过 x表示预期失败 u表示与预期相反 fixture测试夹具以初始化的夹具在前，测试运行结束后的夹具在后运行测试用例。 测试夹具的作用可以把我们在测试运行前和运行结束后需要运行的代码抽离出来，单独放到夹具中区运行。方便我们对代码的组织和维护，减少重复的代码量。 setUp以及setDown是面向测试用例 setUpClass以及tearDownClass是面向测试类 两者可以组合使用同时出现 setUp在每个测试用例前运行，一般在里面写一些实现测试用例的前置条件 tearDown在每个测试用例运行结束后运行，一般在里面写一些清理环境，释放资源之类的代码 setUpClass在每个测试类运行前运行 代码前需要带上@classmethod 装饰器 tearDownClass在每个测试类结束运行之后运行 代码前需要带上@classmethod 装饰器 示例代码1234567891011121314151617181920212223class TestDemo(unittest.TestCase): def setUp(self) -&gt; None: print(&quot;开始运行测试用例&quot;) def tearDown(self) -&gt; None: print(&quot;测试用例运行结束&quot;) @classmethod def setUpClass(cls) -&gt; None: print(&quot;开始运行测试类&quot;) @classmethod def tearDownClass(cls) -&gt; None: print(&quot;测试类结束运行&quot;) def test_01_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) def test_02_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) def test_03_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) 清理函数清理函数默认在tearDown后运行 清理函数的使用，需要先自己封装一个方法，这个方法里面的的代码就是用来清理的 清理函数可以放在测试类中的任何位置，通过addCleanup()注册我们的清理函数 清理函数可以使用doCleanups()对某个用例生效，也可放在setUp中对所有用例生效 在 python3.9 之后新增了addClassCleanup以及doClassCleanup，他们是针对测试类进行清理，用法同上。 addClassCleanup一般与setClassUp搭配使用 12345678910111213141516171819202122232425import unittestdef clear(): print(&quot;开始清理函数&quot;)class TestDemo(unittest.TestCase): def setUp(self) -&gt; None: self.addCleanup(clear) print(&quot;开始运行测试&quot;) def tearDown(self) -&gt; None: print(&quot;测试运行结束&quot;) def test_01_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) def test_02_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) def test_03_demo(self): slf.assertEqual(1, 1, &quot;判断是否相等&quot;) # self.doCleanups() def test_04_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) def test_05_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;)if __name__ == '__main__': unittest.main() 注意：清理函数不是必须要和夹具配置使用，也可以单独使用。 ddt 数据驱动介绍ddt 是 python 的一个专门从来实现数据驱动的第三方的包 使用 ddt 数据驱动来实现数据与测试分离管理 12# 使用pip下载pip install ddt -i https://pypi.douban.com/simple 下载后即可通过导包来使用 ddt 12# 使用Python导包form ddt import ddt, data, unpack, file_data # 装饰器 各项装饰器的使用ddt在测试用例前加上@ddt装饰器即可使用 ddt 数据驱动 12@ddtclass TestDemo(unittest.TestCase): data需要进行测试的数据，放在 data 中。在测试中直接引用 value 即可 1234567891011from ddt import ddt, data, unpack, file_dataimport unittest@ddtclass TestDemo(unittest.TestCase): @data(1, 2, 3) def test_01_demo(self, value): self.assertEqual(1, value, &quot;判断是否相等&quot;)if __name__ == '__main__': unittest.main() file_data可以实现自动的从文件中读取测试数据，不需要像 data 一样手动传入数据。 可以使用 json 或者 yaml 例如在同目录下有名为 data.json 数据文件时 12345{ &quot;01&quot;: { &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23 }, &quot;02&quot;: { &quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24 }, &quot;03&quot;: { &quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25 }} 在测试时可以用@file_data 直接引用 123456789101112from ddt import ddt, data, unpack, file_dataimport unittest@ddtclass TestDemo(unittest.TestCase): @file_data(&quot;data.json&quot;) @unpack def test_05_demo(self, age, name): self.assertEqual(23, age, name)if __name__ == '__main__': unittest.main() 同理在引用 yaml 文件时操作相同，但注意： ddt 是直接支持 json 格式文件的读取，但是对于 yaml 文件需要额外安装一个第三方的python 包才可以。pyyaml 1pip install pyyaml -i https://douban.com/simple unpack对数据进行解包，特别在每项数据都是成组出现时 例如数据内为元组时 1234567891011121314151617from ddt import ddt, data, unpack, file_dataimport unittest@ddtclass TestDemo(unittest.TestCase): # 不使用unpack时 @data((1, 2), (2, 2), (3, 4)) def test_01_demo(self, value): self.assertEqual(value[0], value[1], &quot;判断是否相等&quot;) # 使用unpack时 @data((1, 2), (2, 2), (3, 4)) @unpack def test_02_demo(self,value1, value2): self.assertEqual(value1, value2, &quot;判断是否相等&quot;)if __name__ == '__main__': unittest.main() 例如数据内为字典时 123456789101112131415from ddt import ddt, data, unpack, file_dataimport unittest@ddtclass TestDemo(unittest.TestCase): @data({&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23}, {&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24}, {&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25}) @unpack def test_01_demo(self, name, age): self.assertEqual(23, age, name)if __name__ == '__main__': unittest.main()","link":"/2024/08/29/unittest-ddt/"}],"tags":[{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"web test","slug":"web-test","link":"/tags/web-test/"},{"name":"unittest","slug":"unittest","link":"/tags/unittest/"},{"name":"ddt","slug":"ddt","link":"/tags/ddt/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"web","slug":"web","link":"/tags/web/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"WebTesting","slug":"Python/WebTesting","link":"/categories/Python/WebTesting/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"}],"pages":[{"title":"关于我","text":".heimu { color: #000; background-color: #000; } .heimu:hover { color: #fff; } Hey！ Quirrel(奎若)是一款类银河恶魔城游戏 空洞骑士（Hollow Knight） 中的一名 NPC。在游戏中出现在各种场景来帮助引导主角。每次看到都给人非常可靠的感觉，我想成为这样的人。 我目前在郑州的前端岗位实习中。为什么选前端呢，在初中的时候有了手机接触到网络上的各种东西，虽然我学习一直很好，但是一直都没有什么兴趣。就是喜欢研究手机电脑网络之类的，那时候天天给手机刷机，觉得程序员很厉害，写出来的代码能变成各种样子，我那时才知道：啊，网页是这样做出来的！我那时候还很喜欢去网吧，有次在网吧看着 b 站的教学一步一步通宵用 sublime text3 做出了 b 站的导航栏，甚至要求妈妈买了一个 u 盘和 HTML5+CSS3+JS 的书。后来 U 盘在钥匙链上风吹雨打坏了，书也没看完 从那开始我心里就一直有个前端梦，虽然期间听到很多什么前景不好，内卷严重，但我还是决定 follow my heart。 总之这个网站是用来纪录工作上的经验，学到的知识等笔记。非常感谢一路帮过我的人，希望我们大家一起进步，努力生活。 更多优质文章站点： CSDN：CSDN - 专业开发者社区 MDN：MDN Web Docs (mozilla.org) 码客说：码客说 - 我是码客，我是全栈工程师，我为自己代言。 (psvmc.cn)","link":"/about/index.html"}]}