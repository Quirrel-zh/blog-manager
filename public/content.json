{"posts":[{"title":"第一篇文章","text":"TEST人生不是马拉松，终点不只一个。不管直路弯路，是走是爬，你的路都是独一无二的。不管是穷困或富贵，成功都是你定义的。","link":"/2024/08/19/new/"},{"title":"如何在centOS中配置环境等","text":"本文章于 2023 年学习时记录，无法保证准确性 centOS 安装以及宿主机的连接安装 centOS​ 根据 iso 安装需要版本的 centOS，可选带有桌面或者无桌面的内核版本 检查 centOS 版本以及网络状态12cat /etc/redhat-release # 查询centOS的版本ip addr #查询ip 默认状态下看不到ip 但是需要记住网卡名称例如ens33 ip 地址默认看不到，需要我们设置一下网络配置 12cd /etc/sysconfig/network-scripts #切换目录vi ifcfg-ens33 # 修改指定的网卡 进入到 ifcfg-ens33 之后需要修改BOOTPROTO以及ONBOOT两行 123BOOTPROTO = &quot;dhcp&quot; #更改为静态ipONBOOT = &quot;yes&quot; #更改网卡状态开启# 随后按下esc 输入:wq回车退出 此时 ip 地址即可查看 12ip addr# 找到目标网卡inet后的ip地址 此时可以用 ping www.baidu.com来验证网络是否已连接 使用 Xshell 以及 Xftp 进行连接在 Xshell 新建会话，用户名使用 centOS 中查到的 ip，用户名为 root 密码为初始创建的密码 同理 Xftp 也是一样 JDK 以及 mysql 的环境安装配置JDK 的安装在 usr 目录下新建一个 jdk 的文件12cd /usr/local # 切换目录到指定位置mkdir jdk # 创建名为jdk 的文件 使用 Xftp 进行宿主机与虚拟机间的文件传输将 jdk 压缩包传到/usr/local/jdk 中 使用代码解压 1tar zxvf &quot;jdk文件名.tar.gz&quot; 不同压缩包的解压方式 123456tar –xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2 //解压 tar.bz2tar –xZvf file.tar.Z //解压tar.Zunrar e file.rar //解压rarunzip file.zip //解压zip 编辑环境变量，以及验证 jdk1234567vi /etc/profile # 编辑环境变量# 在文末加入路径代码# jdk configJAVA_HOME=/usr/local/jdk/jdk1.8.0_391CLASS_PATH=$JAVA_HOME/lib/tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASS_PATH PATH 编辑完成按下 esc 键退出编辑模式，再按下**:wq**回车退出保存 使用source /etc/profile使配置生效 验证 java 12java -versionjps mySQL 的安装使用 Xftp 将需要安装的 mysql 传输到虚拟机中 解压改名以及移动文件名以mysql-5.7.43.tar.gz示例 123tar zxvf mysql-5.7.43.tar.gz # 解压mv mysql-5.7.43 mysql # 改名为mysqlmv mysql /usr/local # 移动到常用目录中 创建一个新的 mysql 用户 删除系统已有的数据库 否则会导致 mysql 安装冲突 123# 删除mariadbrpm -qa|grep mariadb # 列出所有mariadb数据库，有多少下面删多少rpm -e --nodeps &quot;要删除的数据库&quot; 创建一个不需要登录的 mysql 账号，给对应的目录授予权限 1234567# 创建不需要登录的mysql账号groupadd mysqluseradd -r -g mysql -s /bin/false mysql# 给予权限chown -R mysql:mysql /usr/local/mysqlmkdir -p /data/mysqlchown -R mysql:mysql /data/mysql 安装依赖1yum -y install libaio # 从云端安装需要的依赖包 初始化 mysql 以及配置环境变量 对 mysql 进行初始化 12cd /usr/local/mysql/bin # 切换到mysql的bin目录./mysqld --user=mysql --initialize # 进行初始化 初始化后会显示初始的 root 账户密码，在最后一行localhost:后，后续需要使用这个密码进行登录 mysql 添加环境变量 首先进入到环境变量配置文件中 1vi /etc/profile 在环境变量最后加入 mysql 路径 1234# mysql congfigMYSQL_HOME=/opt/apps/mysqlPATH=$PATH:{MYSQL_HOME}/binexport MYSQL_HOME PATH 添加到系统服务 进入 mysql.server 进行编辑 12cd support-filesvi mysql.server 进入到编辑页面后修改basedir、datadir以及mysql_pid_file_path的量 123basedir=/usr/local/mysqldatadir=/data/mysql/datamysql_pid_file_path=/data/mysql/mysql.pid 编辑完后按下esc退出编辑模式，再按下:wq保存退出 设置开机启动，更改目录权限 1234567# 给予权限cp mysql.server /etc.init.d/mysqlchmod 755 /etc/init.d/mysql# 启动mysqlservice mysql startchkconfig --add mysqlchkconfig --list 修改 root 密码使用上面准备好的 root 密码登录到 mysql 12mysql -uroot -p# 回车后输入刚刚得到的密码 注意：如果此时显示未找到 mysql 命令时，是因为系统默认查找/usr/bin 下的命令，如果命令不在此处，需要映射一个链接到/usr/bin 目录下 1、找到 mysql 的安装路径 1whereis mysql 2、确定安装路径在/usr/local/mysql/bin/mysql下后，创建一个软连接 1ln -s /usr/local/mysql/bin/mysql /usr/bin 3、再次进行登录尝试 1mysql -uroot -p 登录后修改密码为指定密码 12alter user 'root'@'localhost' identified by '123456'; # 修改密码为123456 注意代码末需要带分号flush privileges; # 刷新权限 tomcat 的安装与部署使用 Xftp 将需要安装的 Tomcat 传输到虚拟机中在/usr/local/目录下新建名为tomcat的文件夹 将需要安装的 Tomcat 通过 Xftp 移动到此处 解压文件1tar -zxvf apache-tomcat.tar.gz 启动 tomcat 首先进入到 tomcat 目录下的bin目录 1cd /usr/local/tomcat/apache-tomcat.9.0.83/bin/ 根据指令启动 tomcat 1./startup.sh 进入到日志验证是否正常启动，并查看开放端口号 12345# 进入日志目录cd ..cd logs/# 查看日志最后100行tail -100f catalina.out 如果日志内没有报错，查看**开始协议处理句柄[“http-nio-8080”]**中后四位的端口号，这里以 8080 举例。 测试访问 tomcat 去浏览器访问ip:端口号的网址 示例192.168.174.130:8080在地址栏直接访问 但是这时会无法访问，需要进行防火墙的开放 开启防火墙端口 1234567# 开启指定端口的防火墙 以8080举例firewall-cmd --zone=public --add-port=8080/tcp --permanent#命令含义： -zone #作用域 -add-port=8080/tcp # 添加端口 格式为：端口/通讯协议 -permanent # 永久生效，没有此参数重启后失效# 重启防火墙firewall-cmd --reload 访问 tomcat 此时去浏览器地址页输入192.168.174.130:8080即可访问 tomcat 主页 部署项目到 tomcact 关闭 tomcat 部署先需要先关闭 tomcat 12345# 返回到bin目录cd ..cd bin/# 输入关闭指令./shutdown.sh 导入项目 将事先准备好的项目通过 Xftp 导入到 tomcat 目录下的/webapps/下，下面以examtest 为例。 访问项目 重新开启 tomcat 12345./startup.sh# 再去日志看看是否正常开启cd ..cd logs/tail -100f catalina.out 成功开启后进入个人项目页面 浏览器访问 192.168.174.130:8080/examtest/ 项目名是什么，端口后就是什么","link":"/2024/08/29/CentOS-jdk/"},{"title":"TypeScript 极速梳理","text":"JavaScript是非常灵活的一门编程语言，但是这种灵活是把双刃剑，一方面使得JavaScript蓬勃发展，无所不能；另一方面也使它的代码质量参差不齐，维护成本高，运行时错误多。 TypeScript是具有类型的JavaScript，在很大程度上弥补了它的缺点。 类型声明给变量声明类型： 123456789101112let a:string // 变量a只能存储字符串let b:number // 变量b只能存储数值let c:boolean // 变量c只能存储布尔值a = 'hello'a = 100 // 警告：不能将类型&quot;number&quot;分配给类型&quot;string&quot;b = 666b = '你好' // 警告：不能将类型&quot;string&quot;分配给类型&quot;number&quot;c = truec = 666 // 警告： 不能将类型&quot;number&quot;分配给类型&quot;boolean&quot; 给参数声明类型 12345678// 给x和y传递参数时必须传递数字类型，返回值也必须是数字function demo(x:number,y:number):number{ return x + y}demo(100, 200)demo(100, '200') // 警告：类型&quot;string&quot;的参数不能赋给类型&quot;number&quot;的参数demo(100, 200, 300) // 警告：应有 2 个参数，但获得 3 个 类型推断在没有声明类型的情况下，ts会自行推断出类型 12let d = -99 // 此时会自动推断变量d的类型为数字d = false // 警告：不能将类型&quot;boolean&quot;分配给类型&quot;number&quot; 类型总览JavaScript中的数据类型： JavaScript string、number、boolean、null、undefined、bigint、symbol、object 备注： 其中object包括：Array、Function、Date….. TypeScript中的数据类型： TypeScript ​ · 以上所有 ​ · 四个新类型：void、 never、unknown、any、enum、tuple ​ · 自定义类型：type&amp;interface 注意：JavaScript中的三个构造函数：Number、String、Boolean，他们只用于包装对象，正常开发时，很少去使用他们，在TypeScript中也是同理 总览： 类型 描述 举例 number 任意数字 1，-1，1.5 string 任意字符串 'nihao'，'你好'，'hello' boolean 布尔值 true&amp;false 字面量 值只能是字面量值 值本身 any 任意类型 1，'hello'，true…… unknown 类型安全的any 1，'hello'，true…… never 不能是任何值 无值 void 空 或 undefined 空 或 undefined object 任意JS对象 {name: '张三'} tuple 元素，TS新增类型，固定长度数组 [3, 4] enum 枚举，TS新增类型 enum{A, B} 常用类型字面量123456789let a:'你好' // a的值只能是字符串'你好'let b:100 // b的值只能是数字100 a = 'hello' // 警告：不能将类型“'hello'”分配给类型“'你好'”b = 200 // 警告：不能将类型“200”分配给类型“100”let gender:'男'|'女' // 定义一个变量gender，值只能为字符串“男”或“女”gender = '男'gender = '未知' // 警告：不能将类型“'未知'”分配给类型“'男'|'女'” anyany的含义是：任何类型。 一旦将变量类型限制为any，那就意味着放弃了对该变量的类型检查。 12345678910111213// 明确表示a的类型是any —— 显式的anylet a:any // 以下对a的赋值，均⽆警告a = 100a = '你好'a = false // 没有明确的表示b的类型是any，但TS主动推断了出来 —— 隐式的anylet b // 以下对b的赋值，均⽆警告b = 100b = '你好'b = false 注意： any 类型的变量，可以赋值给任意类型的变量 ： 123let alet x:stringx = a // ⽆警告 unknownunknown的含义是：未知类型 unknown可以理解为一个类型安全的any unknown适用于：开始不知道数据的具体类型，后期才能确定数据的类型 1234567891011// 设置a的类型为unknownlet a: unknown// 以下对a的赋值均无警告a = 100a = falsea = '你好'// 设置x的数据类型为stringlet x:stringx = a // 警告： 不能将类型'unknown'分配给类型'string' 如果想把a赋值给x， 可以用以下三种写法： 1234567891011121314// 设置a的类型为unknownlet a:unknowna = 'hello'// 1、类型判断if (typeof a === 'string'){ x = a}// 2、断言x = a as string// 3、断言的另外一种写法x = &lt;string&gt;a any后点任何的东西都不会报错，unknown则相反 1234567891011let str1:string = 'hello'str1.toUpperCase() // 无警告let str2:any = 'hello'str2.toUpperCase() // 无警告let str3:unknown = 'hello'str3.toUpperCase() // 警告：&quot;str3&quot;的类型为未知// 使用断言强制指定str3的类型为string(str3 as string).toUpperCase() // 无警告 nevernever的含义是：任何值都不是，简言之就是不能有值，undefined、null、''、0都不行！ 几乎不用never去限制变量，因为没有意义，例如： 12345678// 指定a的类型为never，那就意味着a以后不能存任何的数据let a:never// 以下对a的赋值都会有警告a = 1a = truea = undefineda = null never一般是TypeScript主动推断出来的，例如： 12345678910// 指定a的类型为stringlet a:string// 给a设置一个值a = 'hello'if(typeof a === 'string'){ a.toUpperCase()} else{ console.log(a) // TypeScript会推断出此处的a是never，因为没有任何一个值符合此处的逻辑} never也可以用于限制函数的返回值 1234// 限制demo函数不需要有任何返回值，任何值都不行，想undefined和null都不行function demo():never{ throw new Error('程序异常退出')} voidvoid的含义是：空或者undefined，严格模式下不能加null赋值给void类型。 1234let a:void = undefined// 严格模式下，该行会有警告：不能将类型“null”分配给类型“void”let b:void = null void常用于限制函数返回值 12345678910111213141516171819// 无警告function demo1():void{ }// 无警告function demo2():void{ return}// 无警告function demo3():void{ return undefined}// 警告：不能将类型“number”分配给类型“void”function demo4():void{ return 666} object关于Object与object，直接说结论：在类型限制时，Object几乎不用，因为范围太大没有意义。 object 的含义：任何【⾮原始值类型】，包括：对象、函数、数组等，限制的范围⽐较宽泛，⽤的少 1234567891011121314let a:object // a的值可以是任何【⾮原始值类型】，包括：对象、函数、数组等// 以下代码，是将【⾮原始类型】赋给a，所以均⽆警告a = {}a = {name: '张三'}a = [1, 3, 5, 7, 9]a = function(){} // 以下代码，是将【原始类型】赋给a，有警告a = null // 警告：不能将类型“null”分配给类型“object”a = 1 // 警告：不能将类型“number”分配给类型“object”a = true // 警告：不能将类型“boolean”分配给类型“object”a = undefined // 警告：不能将类型“undefined”分配给类型“object”a = '你好' // 警告：不能将类型“string”分配给类型“object” Object的含义：Object的实例对象，限制范围太大了，几乎不用 1234567891011121314let a:Object //a的值必须是Object的实例对象，// 以下代码，均⽆警告，因为给a赋的值，都是Object的实例对象a = {}a = {name:'张三'}a = [1,3,5,7,9]a = function(){}a = 1 // 1不是Object的实例对象，但其包装对象是Object的实例a = true // true不是Object的实例对象，但其包装对象是Object的实例a = '你好' // “你好”不是Object的实例对象，但其包装对象是Object的实例// 以下代码均有警告a = null // 警告：不能将类型“null”分配给类型“Object”a = undefined // 警告：不能将类型“undefined”分配给类型“Object” 实际开发中，限制一般对象，通常使用一下形式 123456789101112131415161718192021222324// 限制person对象的具体内容，使用','分隔，问号代表可选属性let person:{ name:string, age?:number,}// 限制car对象的具体内容，使用';'分隔，必须有price和color属性，其他属性不去限制，有没有都行let car:{ price: number; color: string; [k:string]:any}// 限制student对象的具体内容，使用'回车'分隔。let student:{ id:string, grade:number,}// 以下代码均无警告person = {name: '张三', age: 18,}person = {name: '李四'}car = {price: 100, color: '红色'}student = {id: '123', grade: 3} 限制函数的参数、返回值，使⽤以下形式 12345let demo:(a:number, b:number) =&gt; numberdemo = function(x, y){ return x + y} 限制数组，使用以下形式 12345let arr1:string[] // 等价于 let arr1:Array&lt;string&gt;let arr2:number[] //等价于 let arr2:Array&lt;number&gt;arr1 = ['a', 'b', 'c']arr2 = [1, 3, 5, 7, 9] tupletuple就是一个长度固定的数组。 123456let t:[string, number]t = ['hello', 123]// 警告：不能将类型“[string, number, boolean]”分配给类型“[string, number]”t = ['hello', 123, false] enumenum是枚举 点击展开 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 定义一个枚举enum Color { Red, Blue, Blace, Gold,}// 定义一个枚举，并指定其初始数值enum Color2{ Red = 6, Blue, Black, Gold,}console.log(Color)/* { 0: 'Red', 1: 'Blue', 2: 'Black', 3: 'Gold', Red: 0, Blue: 1, Black: 2, Gold: 3 } */console.log(Color2)/* { 6: 'Red', 7: 'Blue', 8: 'Black', 9: 'Gold', Red: 6, Blue: 7, Black: 8, Gold: 9 } */// 定义一个phone变量，并对其设置限制let phone: { name:string, price:number, color:Color,}phone = { name: 'iPhone', price: '6000' color: Color.Red}if(phone.color === Color.Red){ console.log('手机是红色的')} 自定义类型⾃定义类型，可以更灵活的限制类型 1234567891011121314151617181920212223242526272829303132// 性别的枚举enum Gender { Male, Female}// ⾃定义⼀个年级类型（⾼⼀、⾼⼆、⾼三）type Grade = 1 | 2 | 3// ⾃定义⼀个学⽣类型type Student = { name: string, age: number, gender: Gender, grade: Grade}// 定义两个学⽣变量：s1、s2let s1:Studentlet s2:Students1 = { name:'张三', age:18, gender:Gender.Male, grade:1}s2 = { name:'李四', age:18, gender:Gender.Female, grade:2} 抽象类常规类： 12345678910111213class Person { name: string age: number constructor(name:string,age:number){ this.name = name this.age = age }}const p1 = new Person('张三',18)const p2 = new Person('李四',19)console.log(p1)console.log(p2) 继承： 12345678910111213141516171819202122232425262728// Person类class Person { name: string age: number}// Teacher类继承Personclass Teacher extends Person { name: string age: number}// Student类继承Personclass Student extends Person { name: string age: number}// Person实例const p1 = new Person('周杰伦', 38)// Student实例const s1 = new Student('张同学', 18)const s2 = new Student('李同学', 20)// Teacher实例const t1 = new Teacher('刘⽼师', 40)const t2 = new Teacher('孙⽼师', 50) 抽象类：不能去实例化，但可以被别⼈继承，抽象类⾥有抽象⽅法 1234567891011121314151617181920212223242526272829// Person（抽象类）abstract class Person { name: string age: number}// Teacher类继承Personclass Teacher extends Person { name: string age: number // 构造器 constructor(name: string, age: number){ super(name, age) } // ⽅法 speak(){ console.log('你好！我是⽼师:', this.name) }}// Student类继承Personclass Student extends Person { name: string age: number}// Person实例// const p1 = new Person('周杰伦',38) // 由于Person是抽象类，所以此处不可以new Person的实例对象 接口接口梳理： 接口用于限制一个类中包含那些属性和方法： 1234567891011121314151617181920212223// Person 接口interface Person { // 属性声明 name: string age: number // 方法声明 speak():void}// Teacher实现Person接口class Teacher implements Person { name: string age: number // 构造器 constructor(name: string, age: number){ this.name = name this.age = age } // 方法 speak(){ console.log('你好，我是：', this.name) }} 接口是可以重复声明的： 123456789101112131415161718192021222324252627// Person接口 interface PersonInter { // 属性声明 name: sting age: number}// Person接口interface PersonInter { // 方法声明 speak():void}// Person类继承PersonInterclass Person implements PersonInter { name: string age: number // 构造器 constructor(name: string, age: number){ this.name = name this.age = age } // 方法 speak(){ console.log('你好，我是：', this.name) }} “接口”与”自定义类型”的区别： 接口可以： ​ 1. 当自定义类型去使用 2. 可以限制类的结构 自定义类型： ​ 1. 仅仅就是自定义类型 123456789101112131415161718192021222324// Person接口interface Person{ // 应该具有的属性 name: string age: number // 应该具有的方法 speak():void}// Person类型/* * type Person = { * name: string * age: number * }*/ // 接口当自定义类型去使用let person:Person = { name: '张三', age: 18, speak(){ console.log(&quot;你好&quot;) }} “接口”与”抽象类”的区别 抽象类： ​ 1. 以有普通方法，也可以有抽象方法​ 2. 用extends关键字去继承抽象类接口中： ​ 1. 只能有抽象方法​ 2. 使用implements关键字去实现接口 抽象类举例： 1234567891011121314151617181920212223242526// 抽象类 ——— Personabstract class Person{ // 属性 name: string age: number // 构造器 constructor(name:string, age:number){ this.name = name this.age = age } // 抽象方法 abstract speak():void // 普通方法 walk(){ console.log('我在走') }}// Teacher类继承抽象类Personclass Teacher extends Person { constructor(name:string, age:number){ super(name, age) } speak(){ console.log(`我是${this.name}`) }} 接口举例： 1234567891011121314151617181920// 接口 ——— Person, 只能包含抽象方法interface Person { // 属性，不写具体值 name: string age: number // 方法，不写具体实现 speak():void}// 创建Teacher类实现Person接口class Teacher implements Person { name: string age: number constructor(name:string, age:number){ this.name = name this.age = age } speak(){ console.log('我在走') }} 属性修饰符 修饰符 含义 解释 readonly 只读属性 属性无法更改 public 公开的 可以在类、子类和对象中修改 protected 受保护的 可以在类、子类中修改 private 私有的 可以在类中修改 泛型定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时就需要泛型了 举例：&lt;T&gt;就是泛型，（不一定非叫&lt;T&gt;），设置泛型之后即可在函数中使用T来表示该类型： 123456789function text&lt;T&gt;(arg: T): T{ return arg;}// 不指明类型，TS会自动推断出来test(10)// 指明具体的类型test&lt;number&gt;(10) 泛型还可以写多个： 123456function test&lt;T, K&gt;(a: T, b: K) K{ return b}// 为多个泛型指定具体值test&lt;number, string&gt;(10, 'hello') 类中同样可以使用泛型 1234567class MyClass&lt;T&gt;{ prop: T constructor(prop: T){ this.prop = prop }} 也可以对泛型的范围进行约束： 1234567891011121314interface Demo{ length: number}// 泛型T必须是MyInter的子类，即：必须拥有length属性function text&lt;T extends Demo&gt;(arg: T): number{ return arg.length}test(10) // 类型“number”的参数不能赋给类型“Demo”的参数test({name: '张三'}) // 类型“test({name: '张三'})”的参数不能赋给类型“Demo”的参数test('123')test({name:'张三', length: 10}) 结语希望以上笔记能对你有帮助，当然如果你在使用TS时弄不清类型，又不想看到警告，完全可以使用any声明。这也是为什么TypeScript又被大家叫做AnyScript🤪","link":"/2024/09/04/TypeScript/"},{"title":"unittest框架总结以及ddt数据驱动","text":"快速入门本文章于 2023 年学习时记录，无法保证准确性 用例编写unittest 是 Python 自带的一个单元测试框架 此外，unittest 还支持自动化测试的接口测试、UI 测试。 12345678910111213import unittestclass TestDemo(unittest.TestCase): def test_01_demo(self): self.assertEqual(1, 2, &quot;判断1和2相等&quot;) def test_02_demo(self): self.assertEqual(1, 1, &quot;判断1和1相等&quot;)if __name__ == '__main__': unittest.main() 使用 unittest 编写测试用例，必须使用测试类来进行。 在测试类里面的方法就是测试用例了。 注意，测试用例的方法必须是以test开头的才可以。 例如上述代码的test_01_demo unittest.main()会自动的发现模块中的所有测试类中的测试用例。 在测试用例中的方法中，我们可以使用testCase自带的断言功能来实现对预期结果和实践结果的判断。 TestSuite我们可以使用测试套件，把不同的测试用例都加载添加到测试套件中 通过直接运行测试套件来实现运行不同模块中的测试用例 12345import unittestsuite = unittest.TestSuite()case = unittest.defaultTestLoader.discover(start_dir='.', pattern=&quot;test*.py&quot;)suite.addTest(case) 上述代码中使用unittest.defaultTestLoader.discover方法就可以实现在指定的文件夹中区自动的发现我们的测试用例 start_dir后面是测试模块所在的文件目录，如果在同一目录则是. pattern参数后跟的是以 test 开头的 python 文件如”test01.py” “test02.py”，因此我们文件要以有规律化的方式起名 最后使用suite.addTest的方法把发现的测试用例加载到测试套件中。 运行套件以及生成测试报告unittest 自带的测试报告是文本格式的，可读性不好，所以我们一般用第三方的模块来生成测试报告 123456789101112import unittestfrom HTMLTestRunner import HTMLTestRunnersuite = unittest.TestSuite()case = unittest.defaultTestLoader.discover(start_dir='.', pattern=&quot;test*.py&quot;)suite.addTest(case)with open(&quot;测试报告.html&quot;, &quot;wb&quot;)as f: runner = HTMLTestRunner(stream=f, title=&quot;测试报告&quot;, description=&quot;这是项目的描述&quot;) runner.run(suite) HTMLTestRunner是我们经常使用的第三方模块，可以将生成的测试报告以 HTML 方式展现。其中： stream是要把测试报告的文件保存到那个文件目录中 title是测试报告的标题 description是对测试报告的详细描述 assert断言常用的断言 assertEqual判断两个值是否相等 assertNotEqual判断两个值是否不相等 assertTrue判断结果是否为真 assertFalse判断结果是否为假 assertIn判断第一个值是否在第二个值范围内 assertNotIn判断第一个值是否不在第二个值的范围内 assertIs判断两个对象是否属于同一对象 assertIsNot判断两个对象是否不属于同一种对象 assertIsNone判断某个值是否为空 assertIsNotNone判断某个是是否不为空 assertIsInstance判断某个对象是否属于某个 class 实例 assertNotIsInstance判断某个对象是否不属于某个 class 实例 代码示例： 12345678910111213141516171819202122232425262728293031import unittestclass Demo: passclass Demo2: passaa = Demoa = 1b = ac = Noneclass TestDemo(unittest.TestCase): def test_01_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) self.assertTrue(1 == 1, &quot;判断结果是否为真&quot;) self.assertFalse(1 == 2, &quot;判断结果是否为假&quot;) self.assertIn(1, [2, 1, 3], &quot;判断第一个值是否在第二个容器内&quot;) self.assertNotIn(1, [3, 2, 3], &quot;判断第一个值是否不在第二个容器内&quot;) self.assertIs(a, b, &quot;判断任意两个对象是否属于同一个对象&quot;) self.assertIsNot(a, 3, &quot;判断任意两个对象是否不属于同一个对象&quot;) self.assertIsNone(c, &quot;判断某个值是否为空值&quot;) self.assertIsNotNone(a, &quot;判断某个值是否不为空&quot;) self.assertIsInstance(aa, Demo, &quot;判断某个对象是否属于某个class实例&quot;) self.assertNotIsInstance(aa, Demo2, &quot;判断某个对象是否不属于某个class实例&quot;)if __name__ == '__main__': unittest.main() unittest装饰器testCase带有很多不同的装饰器来实现我们测试用例的运行过程。 但是在实际工作中会有大量的测试用例，但不是所有的用例都是需要运行的。 有的用例需要根据不同的情况来判断是否需要运行。 我们可以利用testCase自带的装饰器来实现用例运行过程的控制。 装饰器@unittest.skip() 控制某条用例不运行 @unittest.skipif() 如果条件为真，用例不运行 @unittest.skipUnless()如果条件为假，用例不运行 @unittest.expectedFailure预期测试失败，失败时输出x成功时输出u 例如： 1234567891011121314151617181920212223242526272829303132333435class TestDemo(unittest.TestCase): def test_01_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) def test_02_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 1, &quot;判断两个值是否不相等&quot;) @unittest.skip(&quot;跳过第三条用例&quot;) def test_03_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) @unittest.skipIf(True, &quot;结果为真，跳过用例&quot;) def test_04_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) @unittest.skipUnless(False, &quot;结果为假，跳过用例&quot;) def test_05_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) @unittest.expectedFailure # 预期失败 def test_06_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 1, &quot;判断两个值是否不相等&quot;) @unittest.expectedFailure def test_07_demo(self): self.assertEqual(1, 1, &quot;判断两个值是否相等&quot;) self.assertNotEqual(1, 2, &quot;判断两个值是否不相等&quot;) 控制台结果： 1234.Fsssxu======================================================================FAIL: test_02_demo (__main__.TestDemo.test_02_demo)---------------------------------------------------------------------- 运行结果的说明.表示测试通过 F表示测试失败 s表示测试跳过 x表示预期失败 u表示与预期相反 fixture测试夹具以初始化的夹具在前，测试运行结束后的夹具在后运行测试用例。 测试夹具的作用可以把我们在测试运行前和运行结束后需要运行的代码抽离出来，单独放到夹具中区运行。方便我们对代码的组织和维护，减少重复的代码量。 setUp以及setDown是面向测试用例 setUpClass以及tearDownClass是面向测试类 两者可以组合使用同时出现 setUp在每个测试用例前运行，一般在里面写一些实现测试用例的前置条件 tearDown在每个测试用例运行结束后运行，一般在里面写一些清理环境，释放资源之类的代码 setUpClass在每个测试类运行前运行 代码前需要带上@classmethod 装饰器 tearDownClass在每个测试类结束运行之后运行 代码前需要带上@classmethod 装饰器 示例代码1234567891011121314151617181920212223class TestDemo(unittest.TestCase): def setUp(self) -&gt; None: print(&quot;开始运行测试用例&quot;) def tearDown(self) -&gt; None: print(&quot;测试用例运行结束&quot;) @classmethod def setUpClass(cls) -&gt; None: print(&quot;开始运行测试类&quot;) @classmethod def tearDownClass(cls) -&gt; None: print(&quot;测试类结束运行&quot;) def test_01_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) def test_02_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) def test_03_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) 清理函数清理函数默认在tearDown后运行 清理函数的使用，需要先自己封装一个方法，这个方法里面的的代码就是用来清理的 清理函数可以放在测试类中的任何位置，通过addCleanup()注册我们的清理函数 清理函数可以使用doCleanups()对某个用例生效，也可放在setUp中对所有用例生效 在 python3.9 之后新增了addClassCleanup以及doClassCleanup，他们是针对测试类进行清理，用法同上。 addClassCleanup一般与setClassUp搭配使用 12345678910111213141516171819202122232425import unittestdef clear(): print(&quot;开始清理函数&quot;)class TestDemo(unittest.TestCase): def setUp(self) -&gt; None: self.addCleanup(clear) print(&quot;开始运行测试&quot;) def tearDown(self) -&gt; None: print(&quot;测试运行结束&quot;) def test_01_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) def test_02_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) def test_03_demo(self): slf.assertEqual(1, 1, &quot;判断是否相等&quot;) # self.doCleanups() def test_04_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;) def test_05_demo(self): self.assertEqual(1, 1, &quot;判断是否相等&quot;)if __name__ == '__main__': unittest.main() 注意：清理函数不是必须要和夹具配置使用，也可以单独使用。 ddt 数据驱动介绍ddt 是 python 的一个专门从来实现数据驱动的第三方的包 使用 ddt 数据驱动来实现数据与测试分离管理 12# 使用pip下载pip install ddt -i https://pypi.douban.com/simple 下载后即可通过导包来使用 ddt 12# 使用Python导包form ddt import ddt, data, unpack, file_data # 装饰器 各项装饰器的使用ddt在测试用例前加上@ddt装饰器即可使用 ddt 数据驱动 12@ddtclass TestDemo(unittest.TestCase): data需要进行测试的数据，放在 data 中。在测试中直接引用 value 即可 1234567891011from ddt import ddt, data, unpack, file_dataimport unittest@ddtclass TestDemo(unittest.TestCase): @data(1, 2, 3) def test_01_demo(self, value): self.assertEqual(1, value, &quot;判断是否相等&quot;)if __name__ == '__main__': unittest.main() file_data可以实现自动的从文件中读取测试数据，不需要像 data 一样手动传入数据。 可以使用 json 或者 yaml 例如在同目录下有名为 data.json 数据文件时 12345{ &quot;01&quot;: { &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23 }, &quot;02&quot;: { &quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24 }, &quot;03&quot;: { &quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25 }} 在测试时可以用@file_data 直接引用 123456789101112from ddt import ddt, data, unpack, file_dataimport unittest@ddtclass TestDemo(unittest.TestCase): @file_data(&quot;data.json&quot;) @unpack def test_05_demo(self, age, name): self.assertEqual(23, age, name)if __name__ == '__main__': unittest.main() 同理在引用 yaml 文件时操作相同，但注意： ddt 是直接支持 json 格式文件的读取，但是对于 yaml 文件需要额外安装一个第三方的python 包才可以。pyyaml 1pip install pyyaml -i https://douban.com/simple unpack对数据进行解包，特别在每项数据都是成组出现时 例如数据内为元组时 1234567891011121314151617from ddt import ddt, data, unpack, file_dataimport unittest@ddtclass TestDemo(unittest.TestCase): # 不使用unpack时 @data((1, 2), (2, 2), (3, 4)) def test_01_demo(self, value): self.assertEqual(value[0], value[1], &quot;判断是否相等&quot;) # 使用unpack时 @data((1, 2), (2, 2), (3, 4)) @unpack def test_02_demo(self,value1, value2): self.assertEqual(value1, value2, &quot;判断是否相等&quot;)if __name__ == '__main__': unittest.main() 例如数据内为字典时 123456789101112131415from ddt import ddt, data, unpack, file_dataimport unittest@ddtclass TestDemo(unittest.TestCase): @data({&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23}, {&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24}, {&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25}) @unpack def test_01_demo(self, name, age): self.assertEqual(23, age, name)if __name__ == '__main__': unittest.main()","link":"/2024/08/29/unittest-ddt/"},{"title":"【CSS】横竖分割线&#x2F;改变border长度","text":"实现效果 如何在Home下添加如图所示短横线 实践使用border看到的第一眼可能大部分人都会用border-bottom，但是写上之后会发现，效果有点不太对： 123.home h1 { border-bottom: 1px solid #ddd;} 确实是加了一条横线，但是没法调整长度。换一种思路试试 使用伪元素不要把短横线看成border，而是用伪元素来实现。这样不仅是改变长度，大小、颜色、宽度，甚至是可以改变方向 123selector::pseudo-element { property: value;} 伪元素就是用于设置元素指定部分的样式，可用于设置元素的首字母、首行的样式，在元素的内容之前或之后插入内容等 了解更多：[伪元素 - CSS：层叠样式表 | MDN**](**伪元素 - CSS：层叠样式表 | MDN (mozilla.org)) 实现： 1234567891011121314.home h1::after { /* 伪元素必须有content属性*/ content: ''; /* 绝对定位，别忘了给父级添加relative */ position: absolute; left: 0; bottom: 0; /* 宽度为10%，高度为2px */ height: 2px; width: 10%; /* 横线颜色为粉色 */ background-color: pink; box-sizing: border-box;} 来看看效果： 非常完美。接下来看试试看将横线变为纵向的分割线： 123456789101112131415.home h1::after { /* 在h1后方添加元素*/ /* 伪元素必须有content属性*/ content: ''; /* 绝对定位，别忘了给父级添加relative */ position: absolute; right: -10px; top: 50%; transform: translateY(-50%); /* 宽度为2px，高度为30px */ height: 30px; width: 2px; /* 横线颜色为灰色 */ background-color: lightpink; box-sizing: border-box;} 效果： 总结将上述代码总结一下，在以后也可以用在其他场景。 1234567891011selector::after { content: ''; position: absolute; left: 0; top: 0; bottom: 0px; right: 0; height: 0px; width: 0px; background-color: ;} 而且我们不难发现，分割线的横纵其实区别就在于该分割线的宽高值。将width设为1或2像素，height设为想要的长度，那么这个分割线就是纵向的。反之分割线为横向的。","link":"/2024/09/10/CSS-border/"},{"title":"【webpack】webpack快速入门","text":"概念本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个依赖图，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。 快速开始 运行环境 webpack是基于node.js运行的，请确保node.js最低版本为10.13 构建项目首先创建一个文件夹，取任意名字。再进行初始化： npm yarn pnpm npm init -y yarn init -y pnpm init -y 后续我们使用npm进行示例 创建完成之后添加webpack依赖。 1npm add webpack webpack-cli --dev 使用--dev表示将webpack相关的依赖添加的开发者环境中。毕竟我们只有开发的时候会使用到webpack 进行第一次打包使用ide打开项目，并创建src目录，在目录下创建index.js文件。随便在里面写点东西 1console.log('Hello World!') 再去项目更目录创建一个index.html文件。将index.js引入此文件中 1&lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt; 运行网页，在控制台中发现成功打印出了Hello World! 现在进行第一次进行webpack打包，使用命令行运行打包指令： 1npx webpack 这样就完成了第一次打包，并且在项目目录中新加了一个dist目录，目录下有个main.js文件，其中的语句和我们在index.js中编写的一样。因为此时我们没有用到import导入任何的依赖。 这时候我们在html文件中的index.js的引用改为main.js，并更新页面。 1&lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt; 此时控制台依然可以成功打印出Hello World! 添加依赖此时我们试试在有依赖的情况下，打包后的代码是什么样的。首先在src目录下新建一个data.js文件。里面导出一个函数来返回一串博客列表的数据： 123export function getBlogPosts() { return [&quot;blog 1&quot;, &quot;blog 2&quot;, &quot;blog 3&quot;];} 然后在index.js中打印语句进行修改 123import { getBlogPosts } from &quot;./data&quot;;console.log(getBlogPosts()); 此时再运行打包指令npx webpack后，查看main.js中的文件，发现此时语句并不和index.js中一致了 123456// main.js(() =&gt; { 'use strict'; console.log(['blog1', 'blog2', 'blog3']);})(); 说明webpack在打包时自动判断了代码的逻辑，并且简化了代码语句。并且此时再浏览器控制台中依然可以打印出博客列表的数据。 配置文件webpack最核心的一个部分就是他的配置文件，我们可以修改webpack 的各种配置比如入口(entry)、输出(output)、loader、插件(plugin)、模式(mode)、浏览器兼容(browser compatibility)以及环境(environment)。可以浏览webpack官方中文文档来获取详细信息。 概念 | webpack 中文文档 (docschina.org) 修改打包后的文件名我们先试试将打包后的文件名修改一下： 首先在项目根目录下创建一个webpack配置文件: webpack.config.js 在文件中对webpack进行配置： 12345678910const path = require('path') // 引入path模块module.exports = { mode: 'development', // 设置开发环境 entry: './src/index.js', // 入口文件 output: { // 输出 filename: 'dist.js', // 打包后的文件名 path: path.resolve(__dirname, 'dist'), // 打包后的目录 },} 再运行打包指令 npx webpack 此时我们发现在dist目录下新加了一个dist.js文件，这正是我们修改完配置后生成的，并且里面新增了很多代码，这是因为我们现在的环境改成了开发模式。我们再将html文件中引入的js文件修改为dist.js 1&lt;script src=&quot;./dist/dist.js&quot;&gt;&lt;/script&gt; 刷新页面，控制台依旧打印出博客列表数组，这时候我们就可以将旧的main.js文件删除 使用loader来导入CSS文件首先我们先将index.js中的语句修改一下，改为在页面渲染一个列表，为后续添加样式做铺垫 12345678910import { getBlogPosts } from './data';const blogs = getBlogPosts();const ul = document.createElement('ul');blogs.forEach(blog =&gt; { const li = document.createElement('li'); li.innerText = blog; ul.appendChild(li);});document.body.appendChild(ul); 先打包后刷新页面，看看是否渲染出了博客列表: 然后我们在src目录中新建一个style.css文件，随便写点样式 点击展开 >folded1234567891011121314151617181920212223*{margin: 0;padding: 0;}body { display: grid; place-items: center; height: 100vh;}ul { list-style: none;}li { padding: 12px;}img { max-width: 500px;} 我们再将css文件导入到index.js中。这样才能充分利用到webpack，如果在html文件中导入，那就和普通的导入没有什么区别了 123import { getBlogPosts } from './data';// 导入css文件的路径import './style.css'; 如果我们现在直接进行webpack打包，会发现控制台报错 12345678910ERROR in ./src/style.css 1:0Module parse failed: Unexpected token (1:0)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders// 您可能没有合适的loader来加载这种文件类型&gt; * {| margin: 0;| padding: 0; @ ./src/index.js 2:0-21webpack 5.94.0 compiled with 1 error in 53 ms 那是因为我们还没有使用loader来加载css。想要加载css文件我们需要安装两个loader：style-loader、css-loader 12npm add --dev style-loader css-loader// 注意，我们所有关于webpack相关的依赖都使用--dev来添加，因为只有在开发环境中才能用到 安装完成中在webpack.config.js中添加loader，在这里需要要配置使用什么样的文件拓展名来使用哪一个loader 12345678910111213141516171819const path = require('path'); // 引入path模块module.exports = { mode: 'development', // 设置开发环境 entry: './src/index.js', // 入口文件 output: { filename: 'dist.js', // 打包后的文件名 path: path.resolve(__dirname, 'dist'), // 打包后的目录 }, module: { // 模块配置 rules: [ // 规则 { test: /\\.css$/i, // 匹配css文件 使用正则表达式 use: ['style-loader', 'css-loader'], // 使用的loader } ] }}; 然后再运行打包指令，刷新页面。发现网页样式已经改变： 在使用SASS或者Less等css预处理文件，也可以通过对应的loader来配置 如何加载图片对于图片等静态图片的文件，webpack就不用安装额外的loader，直接可以在rules里添加规则 1234{ test: /\\.(png|svg|jpg|jpeg|gif)$/, // 匹配图片文件 type: 'asset/resource', // 使用资源模块类型} 然后在src目录下新建一个静态资源目录assets，在里面创建一个images目录来存放图片。 在index.js文件中导入我们的图片，并且给他设置个名字 1import AvatarImage from './assets/images/avatar.png'; 再引用图片添加到网页的开头 123const img = document.createElement('img');img.src = AvatarImage;document.body.prepend(img); 运行打包命令，刷新网页。发现图片已经成功的渲染到网页中。并且打包目录dist中图片名称也变成了随机的字符串 使用插件自动生成html文件现在我们的html文件是自己手写的，非常容易出错，我们可以借助一个插件来使webpack打包时自动生成一个html文件。这个插件就是html-webpack-plugin 1npm add --dev html-webpack-plugin 在webpack配置文件中引入插件 然后在配置项里添加一个plugins配置项来使用插件 123const HtmlWebpackPlugin = require('html-webpack-plugin'); // 引入html-webpack-plugin插件plugins: [new HtmlWebpackPlugin()], // 使用插件 使用指令打包，这时在打包目录中会生成一个新的html文件。打开发现跟我们之前的页面是一模一样的。 如果我们想给这个网页名称修改，可以在配置项中传递一个对象参数 123456plugins: [ // 使用插件 new HtmlWebpackPlugin({ title: 'List of Blogs', // 设置html的title }), ], 打包并刷新页面，发现网页标题变成了我们修改的标题 使用babel来使js语句更兼容有时候我们写js的时候会用到新的特性，但是有些浏览器不支持，那么可以使用webpack对应的loader来使我们的代码转义为更有兼容性的代码。 比如我们上面写的forEach使用的是箭头函数，我们使用对应的loader之后就会在打包的时候将箭头函数转换成普通函数，来确保适配更多的浏览器。 添加loader依赖 1npm add --dev babel-loader @babel/core @babel/preset-env 在rules中匹配js文件 12345678910{ test: /\\.js$/, // 匹配js文件 exclude: /node_modules/, // 排除node_modules文件夹 use: { loader: 'babel-loader', // 使用babel-loader options: { presets: ['@babel/preset-env'], // 使用babel预设 }, },}, 使用打包命令，然后在dist.js中搜索./src/index.js，可以看到这时的forEach箭头函数被转换成了一个普通函数。说明我们的babel loader生效了 123456// dist.jsblogs.forEach(function (blog) { var li = document.createElement('li'); li.innerText = blog; ul.appendChild(li);}); 压缩打包后的js代码使用terser-webpack-plugin插件可以让我们的js代码在打包后压缩语句，更加轻量化 1npm add --dev terser-webpack-plugin 然后我们在webpack.config.js中导入并使用插件 注意，并不是在pluigins中使用，而是新建一个配置项 12345678const TerserPlugin = require('terser-webpack-plugin'); // 引入压缩插件// 在module.exports中新建一个配置项optimization: { // 优化 minimize: true, // 使用压缩 minimizer: [new TerserPlugin()], // 使用压缩插件}, 运行打包指令，发现dist.js文件中所有的空格都没了，而且变量都被替换成了单个字母进行命名 开发服务器现在我们在每次修改项目的时候都需要手动重新打包，所以webpack提供了一个dev server，也就是开发服务器，在启动之后，如果我们修改了js代码，他就会自动打包并且刷新页面。 安装依赖 1npm add --dev webpack-dev-server 指定dev server要从哪里去加载代码，要在webpack配置文件中添加一个新的配置项 1234567devServer: { // 开发服务器 static: { // 设置服务器根目录 directory: path.join(__dirname, 'dist'), },}, 在package.json中添加一个scripts来启动我们的开发服务器 123&quot;scripts&quot;: { &quot;start&quot;: &quot;webpack serve --open&quot;}, 在命令行中输入指令启动 1npm run start 这时项目就会在端口8080上启动一个本地服务器，并且在浏览器自动打开你的项目。并且在你改动index.js中的代码时，项目会自动打包并且刷新网页。 相信做到这一步会发现，这个和vue或者react等框架启动的时候不是一样的吗。没错，这都是webpack的能力 文件指纹此时每次修改时打包后的dist.js都是相同的文件，因为浏览器有缓存功能，可能会导致在修改后浏览器并不知道你修改了这个文件，直接去取缓存中的dist.js。造成页面没有成功刷新。我们就需要使每次打包后给dist.js文件名中添加一串随机的字符（哈希值的某一段）。我们也可以通过使用webpack来实现 在配置文件中的output配置项中我们的文件名是写死的，这里就要修改我们的文件名为动态的。 1234output: { filename: '[name].[contenthash].js', // 打包后的文件名 使用哈希值避免缓存 path: path.resolve(__dirname, 'dist'), // 打包后的目录 }, 停止服务器 1// 在控制台中使用 ctrl+c 来停止服务器运行 运行打包指令 1npx webpack 这时在dist目录中的就生成了带有哈希值的动态文件名文件，在每次修改时都会打包为不同的文件名，这样就避免了浏览器缓存的问题。 指定文件目录别名我们在引用别的文件时，可能他所在的目录嵌套很深，我们就需要用到很多的.&amp;/，所以webpack可以让你给指定目录添加一个别名，来使我们更方便的导入和引用。 首先我们在src目录下新建一个utils目录，并且在里面新建一个data.js 123export function dataToStr(data) { return `${data.getFullYear()}-${data.getMonth() + 1}-${data.getDate()}`;} 然后再src目录下新建一个test目录，在test目录下新建一个data目录，在data目录下新建一个printData.js文件 123const { dataToStr } = require(&quot;../../utils/data&quot;);console.log(dataToStr(new Date())); 可以看到这时我们导入的路径使用了大量.和/的相对路径 在webpack.config.js中新建一个resolve配置项 12345resolve: { alias: { utils: path.resolve(__dirname, 'src/utils/'), // 设置别名 }}, 然后再将printData.js中的路径直接改为我们设置的utils别名 1const { dataToStr } = require(&quot;utils/data&quot;); 运行打包命令。打包成功，这样就减少了我们引用时使用过多相对路径的问题。 对打包后项目占用可视化有时候我们需要在打包后看看哪个文件占用的空间比较大，来进行项目优化，我们可以用到webpack-bundle-analyzer插件来实现 首先安装依赖 1npm add --dev webpack-bundle-analyzer 在webpack配置文件中，导入插件，并在plugins配置项中使用 12345678910const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin // 引入打包分析插件// 在plugins配置项中添加插件plugins: [ // 使用插件 new HtmlWebpackPlugin({ title: 'List of Blogs', // 设置html的title }), new BundleAnalyzerPlugin() // 使用打包分析插件 ], 然后我们在运行打包命令的时候，会自动打开分析页面，来查看我们当前项目的占用情况 总结这里我们对webpack进行了简单的介绍和示例，了解了webpack的用途和一般配置，如果你想更深入的了解可以访问webpack官方文档来进一步了解，本次示例文件我也同步上传到github项目中，如有需要清随意。 webpack | webpack中文文档 | webpack中文网 (webpackjs.com) Quirrel-zh/webpack-study (github.com) 30 分钟掌握 Webpack_哔哩哔哩_bilibili","link":"/2024/09/21/webpack/"}],"tags":[{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"web test","slug":"web-test","link":"/tags/web-test/"},{"name":"unittest","slug":"unittest","link":"/tags/unittest/"},{"name":"ddt","slug":"ddt","link":"/tags/ddt/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"WebTesting","slug":"Python/WebTesting","link":"/categories/Python/WebTesting/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"CSS","slug":"web/CSS","link":"/categories/web/CSS/"},{"name":"TypeScript","slug":"web/TypeScript","link":"/categories/web/TypeScript/"},{"name":"webpack","slug":"web/webpack","link":"/categories/web/webpack/"}],"pages":[{"title":"关于我","text":".heimu { color: #000; background-color: #000; } .heimu:hover { color: #fff; } Hey！ Quirrel(奎若)是一款类银河恶魔城游戏 空洞骑士（Hollow Knight） 中的一名 NPC。在游戏中出现在各种场景来帮助引导主角。每次看到都给人非常可靠的感觉，我想成为这样的人。 我目前在郑州的前端岗位实习中。为什么选前端呢，在初中的时候有了手机接触到网络上的各种东西，虽然我学习一直很好，但是一直都没有什么兴趣。就是喜欢研究手机电脑网络之类的，那时候天天给手机刷机，觉得程序员很厉害，写出来的代码能变成各种样子，我那时才知道：啊，网页是这样做出来的！我那时候还很喜欢去网吧，有次在网吧看着 b 站的教学一步一步通宵用 sublime text3 做出了 b 站的导航栏，甚至要求妈妈买了一个 u 盘和 HTML5+CSS3+JS 的书。后来 U 盘在钥匙链上风吹雨打坏了，书也没看完 从那开始我心里就一直有个前端梦，虽然期间听到很多什么前景不好，内卷严重，但我还是决定 follow my heart。 总之这个网站是用来纪录工作上的经验，学到的知识等笔记。非常感谢一路帮过我的人，希望我们大家一起进步，努力生活。 更多优质文章站点： CSDN：CSDN - 专业开发者社区 MDN：MDN Web Docs (mozilla.org) 码客说：码客说 - 我是码客，我是全栈工程师，我为自己代言。 (psvmc.cn)","link":"/about/index.html"}]}